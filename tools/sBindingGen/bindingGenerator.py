#!/usr/bin/env python

# Eventually this will be integrated with tasks.py

import sys
import re
import os
import json

scriptMethodSearch = re.compile("([ \t]+)/\*\*\*(.*?)\*/\n\s+ENGINE_SCRIPT_METHOD\((\w+)\);\n", re.DOTALL and re.DOTALL)

def stypeToCPPType(typeName):
	if typeName == "string":
		return "std::string"
	elif typeName == "int":
		return "int"
	elif typeName == "number":
		return "double"
	elif typeName == "bool":
		return "bool"
	else:
		raise "Bad typeName"

def marshalSTypeToCPPValue(typeName, argPosition):
	if typeName == "string":
		return "args.StringValue(" + str(argPosition) + ")"
	elif typeName == "int":
		return "args.Int32Value(" + str(argPosition) + ")"
	elif typeName == "number":
		return "args.NumberValue(" + str(argPosition) + ")"
	elif typeName == "bool":
		return "args.BooleanValue(" + str(argPosition) + ")"
	else:
		raise "Bad typeName"

def marshalSTypeToCPPCheck(typeName, argPosition):
	if typeName == "string":
		return "args[" + str(argPosition) + "].IsString()"
	elif typeName == "int":
		return "args[" + str(argPosition) + "].IsInt32()"
	elif typeName == "number":
		return "args[" + str(argPosition) + "].IsNumber()"
	elif typeName == "bool":
		return "args[" + str(argPosition) + "].IsBoolean()"
	else:
		raise "Bad typeName"

def parseMethod(m):
	whitespace = m.group(1)
	jsonBlob = json.loads(m.group(2))
	methodName = m.group(3)
	ret = ""

	# write generated method signature
	ret += whitespace + "_ENGINE_SCRIPT_METHOD_SIGNATURE(" + methodName + ") {" + "\n"
	ret += whitespace + "    ScriptingManager::Arguments args(_args);" + "\n"

	# assert on flags 
	argsLength = len(jsonBlob["args"])
	ret += whitespace + "    if (args.AssertCount(" + str(argsLength) + ")) return;" + "\n"
	for flag in jsonBlob["flags"]:
		if flag == "requiresGraphicsContext":
			ret += whitespace + "    if (args.Assert(HasGLContext(), \"No OpenGL Context\")) return;" + "\n"

	methodCallArgs = ""
	methodSignature = ""

	methodSignature += stypeToCPPType(jsonBlob["returns"]) + " " + methodName + "("
	methodSignature += "const ScriptingManager::Arguments& ctx"

	index = 0
	for arg in jsonBlob["args"]:
		typeName, argName, helpText = arg
		methodSignature += ", " + stypeToCPPType(typeName) + " " + argName
		methodCallArgs += (", " if (len(methodCallArgs) > 0) else "") + argName
		ret += whitespace + "    if (args.Assert(" + marshalSTypeToCPPCheck(typeName, index) + \
			", \"" + helpText + "\")) return;" + "\n"
		ret += whitespace + "    " + stypeToCPPType(typeName) + " " + argName + " = " + \
			marshalSTypeToCPPValue(typeName, index) + ";" + "\n"
		index += 1

	methodSignature += ");"

	# write method tail
	ret += whitespace + "    args.SetReturnValue(" + methodName + "(args" + \
		(", " + methodCallArgs if len(methodCallArgs) > 0 else "") + "));" + "\n"
	ret += whitespace + "}" + "\n\n"
	return whitespace + "// Generated By bindingGenerator.py" + "\n" + whitespace + methodSignature + "\n\n" + ret

def parseFile(path, filename):
	lines = []
	with open(path, "r") as f:
		lines += f.readlines()
	linesStr = "".join(lines)
	outStr = re.sub(scriptMethodSearch, parseMethod, linesStr)
	with open("src/gen/" + filename, "w") as f:
		f.write(outStr)

def run(srcPath):
	srcFiles = [ f for f in os.listdir(srcPath) if os.path.isfile(os.path.join(srcPath, f)) ]
	for f in srcFiles:
		parseFile(os.path.join(srcPath, f), f)

def main(args):
	run("src/spec")

if __name__ == '__main__':
	main(sys.argv)